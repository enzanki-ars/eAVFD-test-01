<head>
</head>

<body>
  <video id="my-video" width="960" height="400" controls>
    
  </video>
  
  <script src="mux.js"></script>
  
  <script>
    var chunks = ['segments/main-1/001.ts', 'segments/secondary-2/002.ts', 'segments/secondary-3/003.ts', 'segments/secondary-4/004.ts']
	var video = document.getElementById('my-video');
	var currentChunk = 0;

	if (!window.MediaSource) {
		alert('MediaSource API is not available');
	}

	var mediaSource = new MediaSource();

	video.src = window.URL.createObjectURL(mediaSource);
	
	function parseChunk(chunk, sourceBuffer) {
		var transmuxer = new muxjs.mp4.Transmuxer({
			'keepOriginalTimestamps': true
		});
		
		transmuxer.on('data', function (segment) {
			sourceBuffer.appendBuffer(segment.data.buffer);
		});

		transmuxer.push(chunk);
		transmuxer.flush();
			
		console.log('Appending chunk: ' + i);
		if (i === chunks.length - 1) {
			sourceBuffer.addEventListener('updateend', function() {
				if (mediaSource.readyState === 'open') {
					console.log('end');
					mediaSource.endOfStream();
				}
			});
		} else {
			if (video.paused) {
				console.log('play?');
				video.play(); // Start playing after 1st chunk is appended.
			}
		}
		
		if (i < chunks.length) {
			GET(chunks[i+1], parseChunk, sourceBuffer);
		}
	}

	function callback(e) {
		var sourceBuffer = mediaSource.addSourceBuffer('video/mp4;codecs="avc1.4D4028"');
		sourceBuffer.mode = 'sequence';
		
		sourceBuffer.addEventListener('updatestart', function(e) { console.log('updatestart: ' + mediaSource.readyState); });
		sourceBuffer.addEventListener('update', function(e) { console.log('update: ' + mediaSource.readyState); });
		sourceBuffer.addEventListener('updateend', function(e) { console.log('updateend: ' + mediaSource.readyState); });
		sourceBuffer.addEventListener('error', function(e) { console.log('error: ' + mediaSource.readyState); });
		sourceBuffer.addEventListener('abort', function(e) { console.log('abort: ' + mediaSource.readyState); });
		
		console.log('mediaSource readyState: ' + this.readyState);
		
		GET(chunks[0], parseChunk, sourceBuffer);
	}

	mediaSource.addEventListener('sourceopen', callback);
	
	mediaSource.addEventListener('sourceopen', function(e) { console.log('sourceopen: ' + mediaSource.readyState); });
	mediaSource.addEventListener('sourceended', function(e) { console.log('sourceended: ' + mediaSource.readyState); });
	mediaSource.addEventListener('sourceclose', function(e) { console.log('sourceclose: ' + mediaSource.readyState); });
	mediaSource.addEventListener('error', function(e) { console.log('error: ' + mediaSource.readyState); });

	mediaSource.addEventListener('sourceended', function(e) {
		console.log('mediaSource readyState: ' + this.readyState);
	}, false);

	function GET(url, callback, sourceBuffer) {
		var xhr = new XMLHttpRequest();
		xhr.open('GET', url, true);
		xhr.responseType = 'arraybuffer';
		xhr.send();

		xhr.onload = function(e) {
			if (xhr.status != 200) {
				alert("Unexpected status code " + xhr.status + " for " + url);
				return false;
			}
			callback(new Uint8Array(xhr.response), sourceBuffer);
		};
	}
  </script>
</body>